# HTTP Server Application Configuration
# This is the comprehensive configuration file that consolidates all functionality
# including logging, static files, proxy routes, load balancing, WebSocket support,
# health checks, and application settings.

[logging]
# Log level: "debug", "info", "warn", "error"
level = "info"

# Enable/disable file logging (true/false)
file_logging = true

# Directory where log files are stored
logs_directory = "./logs"

# Maximum log file size in MB before rotation
file_size_mb = 10

# Number of days to retain log files
retention_days = 30

# Log format: "text" or "json"
format = "text"

# Console output mode: "both", "file", "console"
# - "both": Output to both console and file (default)
# - "file": File output only 
# - "console": Console output only
output_mode = "both"

# Enable structured logging with additional fields
structured_logging = true

# Request ID generation for traceability
enable_request_ids = true

# Performance metrics logging
enable_performance_metrics = true

[application]
# Application name for logging context
name = "httpserver"

# Environment: "development", "staging", "production"
environment = "development"

# Server configuration
[server]
# Default port if not specified via command line
default_port = 8080

# Request timeout in seconds
request_timeout = 30

# Maximum request body size in MB
max_request_size_mb = 10

# Enable health endpoints
enable_health_endpoints = true

# SSL/TLS configuration
[server.ssl]
enabled = true
https_port = 8443

# Main SSL certificate files
cert_file = "certs/server.crt"
key_file = "certs/server.key"
cert_chain_file = "certs/chain.pem"  # Optional certificate chain

# HTTP to HTTPS redirect configuration
[server.ssl.redirect]
enabled = true
exempt_paths = ["/health", "/ping", "/metrics"]  # Paths that don't require HTTPS

# Wildcard certificate configuration for *.httpserver.io
[server.ssl.wildcard]
enabled = true
domain = "*.httpserver.io"
cert_file = "certs/wildcard.crt"
key_file = "certs/wildcard.key"

# Let's Encrypt integration (future implementation)
[server.ssl.lets_encrypt]
enabled = false
email = "admin@httpserver.io"
domain = "httpserver.io"

# DNS challenge for wildcard certificates
[server.ssl.lets_encrypt.dns_challenge]
provider = "cloudflare"  # DNS provider for DNS-01 challenge
timeout_seconds = 300
credentials = { api_token = "${CLOUDFLARE_API_TOKEN}" }  # Environment variable

# Static file serving configuration
[static_config]
directory = "."
fallback = "index.html"

# Proxy Routes Configuration
# Multiple routes can be defined for different use cases

# API Routes with Load Balancing and Middleware
[[proxy]]
path = "/api/*"
strategy = "round_robin"
timeout = 30
targets = [
    { url = "http://localhost:3000", weight = 1 },
    { url = "http://localhost:3001", weight = 1 },
    { url = "http://localhost:3002", weight = 1 }
]

# Middleware configuration for API routes
[proxy.middleware]
# Header injection and modification
[proxy.middleware.headers]
# Headers to add to requests before forwarding to backend
request_headers = { "X-Gateway" = "RustyWebServer", "X-Request-Source" = "gateway" }
# Headers to add to responses before returning to client
response_headers = { "X-Powered-By" = "RustyWebServer", "X-Cache-Control" = "no-cache" }
# Headers to remove from requests
remove_request_headers = ["X-Internal-Debug"]
# Headers to remove from responses  
remove_response_headers = ["Server", "X-Internal-Info"]
# Override the Host header for backend requests
override_host = "api.backend.com"

# Rate limiting configuration
[proxy.middleware.rate_limit]
requests_per_minute = 1000
window_seconds = 60
max_concurrent = 50
rate_limit_message = "API rate limit exceeded. Please try again later."

# Request/response transformation
[proxy.middleware.transform]
# Request transformations
[proxy.middleware.transform.request]
# Simple text replacements in request body
replace_text = [
    { find = "old_api_version", replace = "v2", regex_enabled = false }
]
# Add fields to JSON request body
add_json_fields = { "gateway_timestamp" = "2025-06-13T10:00:00Z", "processed_by" = "gateway" }
# Remove sensitive fields from JSON request body
remove_json_fields = ["client_secret", "internal_token"]

# Response transformations
[proxy.middleware.transform.response]
# Text replacements in response body
replace_text = [
    { find = "internal.example.com", replace = "api.example.com", regex_enabled = false }
]
# Add fields to JSON response body
add_json_fields = { "response_processed_by" = "gateway", "cache_hint" = "no-cache" }
# Remove internal fields from JSON response body
remove_json_fields = ["internal_id", "debug_info"]

# Authentication middleware
[proxy.middleware.auth]
# Add Bearer token to requests
bearer_token = "gateway-token-12345"
# Custom authentication header (tuple: header_name, header_value)
custom_auth_header = ["X-Gateway-Auth", "gateway-secret"]
# API key configuration
[proxy.middleware.auth.api_key]
header_name = "X-API-Key"
key_value = "backend-api-key-67890"

# Response compression
[proxy.middleware.compression]
gzip = true
brotli = false
threshold_bytes = 1024  # Only compress responses larger than 1KB
level = 6

# SSL configuration for this route (backend communication)
[proxy.ssl]
verify_backend = true          # Verify backend SSL certificates
client_cert_file = "certs/client.crt"    # Client certificate for backend
client_key_file = "certs/client.key"     # Client key for backend

# WebSocket Chat with Sticky Sessions and Health Checks
[[proxy]]
path = "/ws/chat/*"
targets = [
    { url = "http://localhost:5000", weight = 1 },
    { url = "http://localhost:5001", weight = 1 },
    { url = "http://localhost:5002", weight = 1 }
]
strategy = "least_connections"
timeout = 300
sticky_sessions = true

[proxy.websocket_health]
interval = 30
timeout = 5
path = "/health"
ping_message = "ping"

# WebSocket Notifications (Broadcast)
[[proxy]]
path = "/ws/notifications/*"
targets = [
    { url = "http://localhost:6000", weight = 1 },
    { url = "http://localhost:6001", weight = 1 }
]
strategy = "round_robin"
timeout = 600

# WebSocket Realtime Data with Weighted Load Balancing
[[proxy]]
path = "/ws/realtime/*"
targets = [
    { url = "http://localhost:8000", weight = 3 },  # High-performance server
    { url = "http://localhost:8001", weight = 2 },  # Medium-performance server
    { url = "http://localhost:8002", weight = 1 }   # Backup server
]
strategy = "weighted_round_robin"
timeout = 300

# File Upload with Weighted Load Balancing
[[proxy]]
path = "/upload/*"
strategy = "weighted_round_robin"
timeout = 60
targets = [
    { url = "http://localhost:4000", weight = 3 },  # High-performance server
    { url = "http://localhost:4001", weight = 2 },  # Medium-performance server
    { url = "http://localhost:4002", weight = 1 }   # Basic server
]

[proxy.http_health]
interval = 15
timeout = 3
path = "/health"
expected_status_codes = [200, 204]

# Cache Service with Random Load Balancing
[[proxy]]
path = "/cache/*"
strategy = "random"
timeout = 15
targets = [
    { url = "http://localhost:5000", weight = 1 },
    { url = "http://localhost:5001", weight = 1 },
    { url = "http://localhost:5002", weight = 1 },
    { url = "http://localhost:5003", weight = 1 }
]

# Streaming Services with Least Connections
[[proxy]]
path = "/stream/*"
strategy = "least_connections"
timeout = 120
targets = [
    { url = "http://localhost:6000", weight = 1 },
    { url = "http://localhost:6001", weight = 1 }
]

# Admin Routes (Single Target) with Security Middleware
[[proxy]]
path = "/admin/*"
target = "http://localhost:9000"
timeout = 60

# Enhanced security middleware for admin routes
[proxy.middleware]
# Strict rate limiting for admin access
[proxy.middleware.rate_limit]
requests_per_minute = 60  # Stricter limit for admin
window_seconds = 60
max_concurrent = 5        # Low concurrent limit
rate_limit_message = "Admin access rate limit exceeded. Contact administrator."

# Security headers
[proxy.middleware.headers]
request_headers = { "X-Admin-Gateway" = "true", "X-Security-Level" = "high" }
response_headers = { "X-Frame-Options" = "DENY", "X-Content-Type-Options" = "nosniff", "Strict-Transport-Security" = "max-age=31536000; includeSubDomains" }
remove_response_headers = ["Server", "X-Powered-By"]

# Admin authentication
[proxy.middleware.auth]
bearer_token = "admin-secure-token-98765"

# SSL configuration for admin route (enhanced security)
[proxy.ssl]
verify_backend = true          # Strict certificate verification for admin
client_cert_file = "certs/admin-client.crt"    # Admin client certificate
client_key_file = "certs/admin-client.key"     # Admin client key

# Health Check Endpoint
[[proxy]]
path = "/health"
target = "http://localhost:9000"
timeout = 10

# Metrics Endpoint
[[proxy]]
path = "/metrics"
target = "http://localhost:9001"
timeout = 15

# Legacy Single WebSocket Endpoint
[[proxy]]
path = "/ws/events"
target = "http://localhost:7000"
timeout = 300
