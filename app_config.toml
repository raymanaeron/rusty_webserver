# HTTP Server Application Configuration
# This is the comprehensive configuration file that consolidates all functionality
# including logging, static files, proxy routes, load balancing, WebSocket support,
# health checks, and application settings.

[logging]
# Log level: "debug", "info", "warn", "error"
level = "info"

# Enable/disable file logging (true/false)
file_logging = true

# Directory where log files are stored
logs_directory = "./logs"

# Maximum log file size in MB before rotation
file_size_mb = 10

# Number of days to retain log files
retention_days = 30

# Log format: "text" or "json"
format = "text"

# Console output mode: "both", "file", "console"
# - "both": Output to both console and file (default)
# - "file": File output only 
# - "console": Console output only
output_mode = "both"

# Enable structured logging with additional fields
structured_logging = true

# Request ID generation for traceability
enable_request_ids = true

# Performance metrics logging
enable_performance_metrics = true

[application]
# Application name for logging context
name = "httpserver"

# Environment: "development", "staging", "production"
environment = "development"

# Server configuration
[server]
# Default port if not specified via command line
default_port = 8080

# Request timeout in seconds
request_timeout = 30

# Maximum request body size in MB
max_request_size_mb = 10

# Enable health endpoints
enable_health_endpoints = true

# SSL/TLS configuration
[server.ssl]
enabled = true
https_port = 8443

# Main SSL certificate files
cert_file = "certs/server.crt"
key_file = "certs/server.key"
cert_chain_file = "certs/chain.pem"  # Optional certificate chain

# HTTP to HTTPS redirect configuration
[server.ssl.redirect]
enabled = true
exempt_paths = ["/health", "/ping", "/metrics"]  # Paths that don't require HTTPS

# Wildcard certificate configuration for *.httpserver.io
[server.ssl.wildcard]
enabled = true
domain = "*.httpserver.io"
cert_file = "certs/wildcard.crt"
key_file = "certs/wildcard.key"

# Let's Encrypt integration (future implementation)
[server.ssl.lets_encrypt]
enabled = false
email = "admin@httpserver.io"
domain = "httpserver.io"

# DNS challenge for wildcard certificates
[server.ssl.lets_encrypt.dns_challenge]
provider = "cloudflare"  # DNS provider for DNS-01 challenge
timeout_seconds = 300
credentials = { api_token = "${CLOUDFLARE_API_TOKEN}" }  # Environment variable

# Static file serving configuration
[static_config]
directory = "."
fallback = "index.html"

# Proxy Routes Configuration
# Multiple routes can be defined for different use cases

# API Routes with Load Balancing and Middleware
[[proxy]]
path = "/api/*"
strategy = "round_robin"
timeout = 30
targets = [
    { url = "http://localhost:3000", weight = 1 },
    { url = "http://localhost:3001", weight = 1 },
    { url = "http://localhost:3002", weight = 1 }
]

# Middleware configuration for API routes
[proxy.middleware]
# Header injection and modification
[proxy.middleware.headers]
# Headers to add to requests before forwarding to backend
request_headers = { "X-Gateway" = "RustyWebServer", "X-Request-Source" = "gateway" }
# Headers to add to responses before returning to client
response_headers = { "X-Powered-By" = "RustyWebServer", "X-Cache-Control" = "no-cache" }
# Headers to remove from requests
remove_request_headers = ["X-Internal-Debug"]
# Headers to remove from responses  
remove_response_headers = ["Server", "X-Internal-Info"]
# Override the Host header for backend requests
override_host = "api.backend.com"

# Rate limiting configuration
[proxy.middleware.rate_limit]
requests_per_minute = 1000
window_seconds = 60
max_concurrent = 50
rate_limit_message = "API rate limit exceeded. Please try again later."

# Request/response transformation
[proxy.middleware.transform]
# Request transformations
[proxy.middleware.transform.request]
# Simple text replacements in request body
replace_text = [
    { find = "old_api_version", replace = "v2", regex_enabled = false }
]
# Add fields to JSON request body
add_json_fields = { "gateway_timestamp" = "2025-06-13T10:00:00Z", "processed_by" = "gateway" }
# Remove sensitive fields from JSON request body
remove_json_fields = ["client_secret", "internal_token"]

# Response transformations
[proxy.middleware.transform.response]
# Text replacements in response body
replace_text = [
    { find = "internal.example.com", replace = "api.example.com", regex_enabled = false }
]
# Add fields to JSON response body
add_json_fields = { "response_processed_by" = "gateway", "cache_hint" = "no-cache" }
# Remove internal fields from JSON response body
remove_json_fields = ["internal_id", "debug_info"]

# Authentication middleware
[proxy.middleware.auth]
# Add Bearer token to requests
bearer_token = "gateway-token-12345"
# Custom authentication header (tuple: header_name, header_value)
custom_auth_header = ["X-Gateway-Auth", "gateway-secret"]
# API key configuration
[proxy.middleware.auth.api_key]
header_name = "X-API-Key"
key_value = "backend-api-key-67890"

# Response compression
[proxy.middleware.compression]
gzip = true
brotli = false
threshold_bytes = 1024  # Only compress responses larger than 1KB
level = 6

# SSL configuration for this route (backend communication)
[proxy.ssl]
verify_backend = true          # Verify backend SSL certificates
client_cert_file = "certs/client.crt"    # Client certificate for backend
client_key_file = "certs/client.key"     # Client key for backend

# WebSocket Chat with Sticky Sessions and Health Checks
[[proxy]]
path = "/ws/chat/*"
targets = [
    { url = "http://localhost:5000", weight = 1 },
    { url = "http://localhost:5001", weight = 1 },
    { url = "http://localhost:5002", weight = 1 }
]
strategy = "least_connections"
timeout = 300
sticky_sessions = true

[proxy.websocket_health]
interval = 30
timeout = 5
path = "/health"
ping_message = "ping"

# WebSocket Notifications (Broadcast)
[[proxy]]
path = "/ws/notifications/*"
targets = [
    { url = "http://localhost:6000", weight = 1 },
    { url = "http://localhost:6001", weight = 1 }
]
strategy = "round_robin"
timeout = 600

# WebSocket Realtime Data with Weighted Load Balancing
[[proxy]]
path = "/ws/realtime/*"
targets = [
    { url = "http://localhost:8000", weight = 3 },  # High-performance server
    { url = "http://localhost:8001", weight = 2 },  # Medium-performance server
    { url = "http://localhost:8002", weight = 1 }   # Backup server
]
strategy = "weighted_round_robin"
timeout = 300

# File Upload with Weighted Load Balancing
[[proxy]]
path = "/upload/*"
strategy = "weighted_round_robin"
timeout = 60
targets = [
    { url = "http://localhost:4000", weight = 3 },  # High-performance server
    { url = "http://localhost:4001", weight = 2 },  # Medium-performance server
    { url = "http://localhost:4002", weight = 1 }   # Basic server
]

[proxy.http_health]
interval = 15
timeout = 3
path = "/health"
expected_status_codes = [200, 204]

# Cache Service with Random Load Balancing
[[proxy]]
path = "/cache/*"
strategy = "random"
timeout = 15
targets = [
    { url = "http://localhost:5000", weight = 1 },
    { url = "http://localhost:5001", weight = 1 },
    { url = "http://localhost:5002", weight = 1 },
    { url = "http://localhost:5003", weight = 1 }
]

# Streaming Services with Least Connections
[[proxy]]
path = "/stream/*"
strategy = "least_connections"
timeout = 120
targets = [
    { url = "http://localhost:6000", weight = 1 },
    { url = "http://localhost:6001", weight = 1 }
]

# Admin Routes (Single Target) with Security Middleware
[[proxy]]
path = "/admin/*"
target = "http://localhost:9000"
timeout = 60

# Enhanced security middleware for admin routes
[proxy.middleware]
# Strict rate limiting for admin access
[proxy.middleware.rate_limit]
requests_per_minute = 60  # Stricter limit for admin
window_seconds = 60
max_concurrent = 5        # Low concurrent limit
rate_limit_message = "Admin access rate limit exceeded. Contact administrator."

# Security headers
[proxy.middleware.headers]
request_headers = { "X-Admin-Gateway" = "true", "X-Security-Level" = "high" }
response_headers = { "X-Frame-Options" = "DENY", "X-Content-Type-Options" = "nosniff", "Strict-Transport-Security" = "max-age=31536000; includeSubDomains" }
remove_response_headers = ["Server", "X-Powered-By"]

# Admin authentication
[proxy.middleware.auth]
bearer_token = "admin-secure-token-98765"

# SSL configuration for admin route (enhanced security)
[proxy.ssl]
verify_backend = true          # Strict certificate verification for admin
client_cert_file = "certs/admin-client.crt"    # Admin client certificate
client_key_file = "certs/admin-client.key"     # Admin client key

# Health Check Endpoint
[[proxy]]
path = "/health"
target = "http://localhost:9000"
timeout = 10

# Metrics Endpoint
[[proxy]]
path = "/metrics"
target = "http://localhost:9001"
timeout = 15

# Legacy Single WebSocket Endpoint
[[proxy]]
path = "/ws/events"
target = "http://localhost:7000"
timeout = 300

# ========================================
# TUNNEL CONFIGURATION (Phase 7.1 & 7.2)
# ========================================

[tunnel]
# Enable tunnel functionality (both client and server)
enabled = false

# Local port to tunnel (defaults to server port if not specified)
local_port = 8080

# Local host to bind to
local_host = "127.0.0.1"

# Tunnel endpoints configuration (for client mode)
[[tunnel.endpoints]]
# Tunnel server URL (WebSocket endpoint)
server_url = "wss://tunnel.httpserver.io/connect"

# Requested subdomain (optional, server may assign one)
subdomain = "my-app"

# Protocol version
protocol_version = "1.0"

# Connection timeout in seconds
connection_timeout = 30

# Keep-alive interval in seconds
keepalive_interval = 30

# Maximum concurrent connections through this tunnel
max_connections = 100

# Authentication configuration (for client)
[tunnel.auth]
# Authentication method: "api_key", "token", or "certificate"
method = "api_key"

# API key for authentication (required for api_key method)
api_key = "your-api-key-here"

# Authentication token (for token method)
# token = "your-token-here"

# Client certificate for mutual TLS (for certificate method)
# cert_file = "certs/client.crt"
# key_file = "certs/client.key"

# User account information
# user = "username"

# Additional authentication headers
[tunnel.auth.headers]
# "X-Custom-Header" = "custom-value"

# Token refresh settings (for token method)
[tunnel.auth.token_refresh]
# Enable automatic token refresh
enabled = false

# Refresh endpoint URL
# refresh_url = "https://auth.httpserver.io/refresh"

# Refresh interval in seconds (1 hour)
interval = 3600

# Refresh token
# refresh_token = "your-refresh-token"

# Auto-reconnection configuration
[tunnel.reconnection]
# Enable auto-reconnection
enabled = true

# Initial retry delay in seconds
initial_delay = 1

# Maximum retry delay in seconds (5 minutes)
max_delay = 300

# Backoff multiplier
backoff_multiplier = 2.0

# Maximum retry attempts (0 = unlimited)
max_attempts = 0

# Jitter factor for retry delays
jitter_factor = 0.1

# Status monitoring configuration
[tunnel.monitoring]
# Enable status monitoring
enabled = true

# Health check interval in seconds
health_interval = 60

# Connection metrics collection
collect_metrics = true

# Status update callback URL
# status_webhook = "https://your-app.com/webhook/tunnel-status"

# Log tunnel events
log_events = true

# SSL/TLS configuration for tunnel connections
[tunnel.ssl]
# Verify server certificates
verify_server = true

# Custom CA certificate bundle
# ca_file = "certs/ca.pem"

# Client certificate for mutual TLS
# client_cert = "certs/client.crt"

# Client private key
# client_key = "certs/client.key"

# SNI hostname override
# sni_hostname = "tunnel.httpserver.io"

# ALPN protocols
alpn_protocols = []

# ========================================
# TUNNEL SERVER CONFIGURATION (Phase 7.2)
# ========================================

[tunnel.server]
# Enable tunnel server functionality
enabled = false

# Port for tunnel WebSocket connections (configurable)
tunnel_port = 8081

# Base domain for tunnel subdomains
base_domain = "httpserver.io"

# Public HTTP port (where subdomain traffic is served) - configurable
public_port = 80

# Public HTTPS port for SSL tunnel traffic - configurable
public_https_port = 443

# Maximum number of concurrent tunnels
max_tunnels = 1000

# Subdomain allocation strategy: "Random", "Uuid", or "UserSpecified"
subdomain_strategy = "Random"

# Default subdomain length (for random strategy)
subdomain_length = 8

# Reserved subdomains that cannot be allocated
reserved_subdomains = ["www", "api", "admin", "mail", "ftp", "secure", "app", "tunnel"]

# Tunnel server authentication configuration
[tunnel.server.auth]
# Require authentication for tunnel connections
required = true

# API keys for authentication
api_keys = ["dev-key-123", "staging-key-456", "prod-key-789"]

# JWT authentication settings
[tunnel.server.auth.jwt]
enabled = false
# secret = "your-jwt-secret-key-here"
# issuer = "httpserver-tunnel"
# audience = "tunnel-clients"
# expiration_hours = 24

# Rate limiting configuration
[tunnel.server.rate_limit]
# Enable rate limiting
enabled = true

# Maximum requests per tunnel per minute
requests_per_minute = 1000

# Maximum concurrent connections per tunnel
max_connections_per_tunnel = 50

# Maximum bandwidth per tunnel (bytes per second)
max_bandwidth_per_tunnel = 10485760  # 10 MB/s

# Burst allowance for rate limiting
burst_allowance = 100

# Rate limiting window in seconds
window_seconds = 60

# SSL/TLS configuration for tunnel server
[tunnel.server.ssl]
# Enable SSL for public endpoints
enabled = true

# Certificate file path
cert_file = "certs/tunnel-server.crt"

# Private key file path
key_file = "certs/tunnel-server.key"

# Certificate chain file (optional)
cert_chain_file = "certs/tunnel-chain.pem"

# Supported TLS versions
min_tls_version = "1.2"
max_tls_version = "1.3"

# Cipher suites (empty = default secure ciphers)
cipher_suites = []

# ALPN protocols for tunnel server
alpn_protocols = ["h2", "http/1.1"]

# Health monitoring for tunnel server
[tunnel.server.monitoring]
# Enable server health monitoring
enabled = true

# Health check endpoint path
health_endpoint = "/health"

# Metrics collection
collect_metrics = true

# Metrics endpoint path
metrics_endpoint = "/metrics"

# Server status logging
log_server_status = true

# Log tunnel connections/disconnections
log_tunnel_events = true

# Status dashboard endpoint
status_endpoint = "/status"

# Performance monitoring
[tunnel.server.performance]
# Connection pool settings
connection_pool_size = 1000

# Worker thread count (0 = auto-detect based on CPU cores)
worker_threads = 0

# Buffer sizes for WebSocket communication (bytes)
websocket_buffer_size = 65536

# HTTP request buffer size (bytes)
http_buffer_size = 32768

# Tunnel cleanup interval (seconds)
cleanup_interval = 300

# Maximum concurrent HTTP requests per tunnel
max_concurrent_requests = 100

# Request queue size per tunnel
request_queue_size = 1000

# Security settings
[tunnel.server.security]
# Enable CORS for public endpoints
cors_enabled = true

# Allowed origins for CORS (empty = all origins allowed)
cors_origins = []

# Request validation
validate_host_headers = true
validate_content_length = true

# Maximum request size (bytes) - 100 MB default
max_request_size = 104857600

# Maximum response size (bytes) - 100 MB default
max_response_size = 104857600

# Connection timeout settings (seconds)
connection_timeout = 60
idle_timeout = 300

# WebSocket ping interval (seconds)
websocket_ping_interval = 30

# Anti-abuse settings
max_subdomain_length = 32
min_subdomain_length = 3
block_suspicious_patterns = true

# Rate limiting for subdomain allocation
max_subdomains_per_ip = 10
subdomain_allocation_window = 3600  # 1 hour

# Network configuration
[tunnel.server.network]
# Bind address for tunnel server (0.0.0.0 = all interfaces)
bind_address = "0.0.0.0"

# Bind address for public traffic (0.0.0.0 = all interfaces)
public_bind_address = "0.0.0.0"

# Enable IPv6 support
ipv6_enabled = true

# TCP keepalive settings
tcp_keepalive = true
tcp_keepalive_idle = 600
tcp_keepalive_interval = 60
tcp_keepalive_probes = 9

# Socket reuse options
socket_reuse_address = true
socket_reuse_port = false
